<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snakey Snacks - Retro Snake Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --neon-pink: #ff00ff;
            --neon-cyan: #00ffff;
            --neon-green: #00ff00;
            --neon-yellow: #ffff00;
            --neon-orange: #ff8800;
            --neon-red: #ff0044;
            --dark-bg: #0a0a0a;
            --darker-bg: #050505;
            --grid-color: #1a1a2e;
        }

        /* High Contrast Mode */
        body.high-contrast {
            --neon-pink: #ff66ff;
            --neon-cyan: #66ffff;
            --neon-green: #66ff66;
            --neon-yellow: #ffff66;
            --dark-bg: #000000;
            --darker-bg: #000000;
        }
        body.high-contrast .game-container { border: 3px solid #fff; }
        body.high-contrast #gameCanvas { border: 3px solid #fff; }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
        }
        body.reduced-motion *, body.reduced-motion *::before, body.reduced-motion *::after {
            animation-duration: 0.01ms !important; transition-duration: 0.01ms !important;
        }

        /* Colorblind modes */
        body.colorblind-deuteranopia { filter: url('#deuteranopia-filter'); }
        body.colorblind-protanopia { filter: url('#protanopia-filter'); }
        body.colorblind-tritanopia { filter: url('#tritanopia-filter'); }

        body {
            font-family: 'Press Start 2P', cursive;
            background: var(--dark-bg);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(ellipse at 20% 80%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(0, 255, 0, 0.05) 0%, transparent 70%);
            pointer-events: none;
            transition: all 0.5s ease;
        }

        /* Theme backgrounds */
        body.theme-space::before {
            background:
                radial-gradient(ellipse at 10% 20%, rgba(100, 100, 255, 0.2) 0%, transparent 40%),
                radial-gradient(ellipse at 90% 80%, rgba(150, 50, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(0, 0, 50, 0.3) 0%, transparent 70%);
        }

        body.theme-forest::before {
            background:
                radial-gradient(ellipse at 20% 80%, rgba(0, 100, 0, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(50, 150, 50, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(0, 80, 0, 0.1) 0%, transparent 70%);
        }

        body.theme-underwater::before {
            background:
                radial-gradient(ellipse at 20% 80%, rgba(0, 100, 150, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0, 150, 200, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(0, 50, 100, 0.2) 0%, transparent 70%);
        }

        .game-container {
            display: flex;
            gap: 30px;
            padding: 30px;
            background: linear-gradient(145deg, #0d0d0d, #1a1a1a);
            border-radius: 20px;
            box-shadow:
                0 0 40px rgba(255, 0, 255, 0.3),
                0 0 80px rgba(0, 255, 255, 0.2),
                inset 0 0 60px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 0, 255, 0.3);
            position: relative;
            z-index: 1;
            transition: transform 0.1s ease;
        }

        .game-container.shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .game-container:fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 250px;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 900;
            text-align: center;
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-cyan), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite alternate;
            margin-bottom: 5px;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 10px var(--neon-pink)); }
            to { filter: drop-shadow(0 0 20px var(--neon-cyan)); }
        }

        .panel-section {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .panel-section h3 {
            color: var(--neon-cyan);
            font-size: 9px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        .panel-section.green { border-color: var(--neon-green); box-shadow: 0 0 15px rgba(0, 255, 0, 0.2); }
        .panel-section.green h3 { color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green); }

        .panel-section.yellow { border-color: var(--neon-yellow); box-shadow: 0 0 15px rgba(255, 255, 0, 0.2); }
        .panel-section.yellow h3 { color: var(--neon-yellow); text-shadow: 0 0 10px var(--neon-yellow); }

        .panel-section.orange { border-color: var(--neon-orange); box-shadow: 0 0 15px rgba(255, 136, 0, 0.2); }
        .panel-section.orange h3 { color: var(--neon-orange); text-shadow: 0 0 10px var(--neon-orange); }

        .panel-section.pink { border-color: var(--neon-pink); box-shadow: 0 0 15px rgba(255, 0, 255, 0.2); }
        .panel-section.pink h3 { color: var(--neon-pink); text-shadow: 0 0 10px var(--neon-pink); }

        .player-input {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--neon-pink);
            border-radius: 5px;
            color: var(--neon-green);
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            outline: none;
            transition: all 0.3s ease;
        }

        .player-input:focus {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row:last-child { border-bottom: none; }

        .stat-label {
            color: #888;
            font-size: 7px;
        }

        .stat-value {
            font-size: 11px;
            font-weight: bold;
        }

        .score-value { color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green); }
        .high-score-value { color: var(--neon-yellow); text-shadow: 0 0 10px var(--neon-yellow); }
        .level-value { color: var(--neon-orange); text-shadow: 0 0 10px var(--neon-orange); }
        .length-value { color: var(--neon-cyan); text-shadow: 0 0 10px var(--neon-cyan); }
        .time-value { color: var(--neon-pink); text-shadow: 0 0 10px var(--neon-pink); }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .canvas-container {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.3),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            display: block;
            background: var(--darker-bg);
            border: 3px solid var(--neon-cyan);
            border-radius: 10px;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            border-radius: 10px;
            opacity: 1;
            transition: opacity 0.3s ease;
            overflow-y: auto;
            padding: 20px;
        }

        .game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 900;
            color: var(--neon-pink);
            text-shadow: 0 0 30px var(--neon-pink);
            animation: pulse 1s ease-in-out infinite;
        }

        .overlay-subtitle {
            font-size: 10px;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        .overlay-score {
            font-size: 16px;
            color: var(--neon-green);
            text-shadow: 0 0 15px var(--neon-green);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        .btn {
            padding: 12px 24px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(145deg, var(--neon-pink), #cc00cc);
            color: white;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .btn-secondary {
            background: linear-gradient(145deg, var(--neon-cyan), #00cccc);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 8px;
        }

        .game-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .right-panel {
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 7px;
        }

        .leaderboard-entry.gold { border: 1px solid gold; background: rgba(255, 215, 0, 0.1); }
        .leaderboard-entry.silver { border: 1px solid silver; background: rgba(192, 192, 192, 0.1); }
        .leaderboard-entry.bronze { border: 1px solid #cd7f32; background: rgba(205, 127, 50, 0.1); }

        .rank {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            font-weight: bold;
            font-size: 8px;
        }

        .rank-1 { background: gold; color: #000; }
        .rank-2 { background: silver; color: #000; }
        .rank-3 { background: #cd7f32; color: #000; }
        .rank-default { background: #333; color: #fff; }

        .entry-name {
            flex-grow: 1;
            margin-left: 8px;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entry-score {
            color: var(--neon-green);
            font-weight: bold;
        }

        /* Menu Styles */
        .menu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 400px;
        }

        .menu-btn {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--neon-cyan);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .menu-btn.selected {
            background: rgba(0, 255, 255, 0.2);
            border-color: var(--neon-pink);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .menu-btn-title {
            color: var(--neon-cyan);
            font-size: 10px;
            margin-bottom: 5px;
        }

        .menu-btn-desc {
            color: #666;
            font-size: 7px;
            line-height: 1.4;
        }

        /* Settings Styles */
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-label {
            color: #aaa;
            font-size: 8px;
        }

        .settings-control {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .toggle-btn {
            padding: 5px 10px;
            font-size: 7px;
            background: #333;
            border: 1px solid #555;
            color: #888;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn.active {
            background: var(--neon-cyan);
            border-color: var(--neon-cyan);
            color: #000;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            -webkit-appearance: none;
            width: 80px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--neon-cyan);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        .slider-value {
            color: var(--neon-cyan);
            font-size: 8px;
            min-width: 30px;
            text-align: right;
        }

        /* Skin/Theme Selection */
        .selection-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 5px;
        }

        .skin-btn, .theme-btn {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid #333;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .skin-btn:hover, .theme-btn:hover {
            transform: scale(1.1);
        }

        .skin-btn.selected, .theme-btn.selected {
            border-color: var(--neon-pink);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }

        .skin-classic { background: linear-gradient(135deg, #ff00ff, #cc00cc); }
        .skin-rainbow { background: linear-gradient(135deg, red, orange, yellow, green, blue, purple); }
        .skin-fire { background: linear-gradient(135deg, #ff0000, #ff8800, #ffff00); }
        .skin-ice { background: linear-gradient(135deg, #00ffff, #0088ff, #0044ff); }
        .skin-pixel { background: #00ff00; image-rendering: pixelated; }

        .theme-default { background: linear-gradient(135deg, #0a0a0a, #1a1a2e); }
        .theme-space { background: linear-gradient(135deg, #0a0a2e, #1a0a3e); }
        .theme-forest { background: linear-gradient(135deg, #0a1a0a, #1a2e1a); }
        .theme-underwater { background: linear-gradient(135deg, #0a1a2e, #0a2e3e); }

        /* Tutorial Styles */
        .tutorial-step {
            text-align: center;
            max-width: 350px;
        }

        .tutorial-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .tutorial-text {
            color: #aaa;
            font-size: 8px;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .tutorial-keys {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 15px 0;
        }

        .tutorial-key {
            width: 35px;
            height: 35px;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 2px solid var(--neon-pink);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--neon-pink);
            font-size: 10px;
        }

        .tutorial-nav {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .tutorial-dots {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s ease;
        }

        .tutorial-dot.active {
            background: var(--neon-cyan);
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        /* Boss indicator */
        .boss-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--neon-red);
            font-size: 12px;
            text-shadow: 0 0 20px var(--neon-red);
            animation: bossFlash 0.5s ease-in-out infinite alternate;
        }

        @keyframes bossFlash {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

        /* Timer bar for timed mode */
        .timer-bar-container {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-yellow), var(--neon-red));
            transition: width 0.1s linear;
        }

        /* Food legend */
        .food-legend {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .food-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 7px;
            color: #888;
        }

        .food-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
        }

        /* Particle effects */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particleFade 0.5s ease-out forwards;
        }

        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }

        /* Trail effect */
        .trail {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: trailFade 0.3s ease-out forwards;
        }

        @keyframes trailFade {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }

        /* Mobile */
        .touch-controls {
            display: none;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        @media (max-width: 1000px) {
            .game-container {
                flex-direction: column;
                padding: 15px;
                max-height: 95vh;
                overflow-y: auto;
            }

            .left-panel, .right-panel {
                min-width: auto;
            }

            .touch-controls {
                display: flex;
            }

            .menu-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--neon-pink);
            border-radius: 3px;
        }

        /* Power-up timer bar */
        .powerup-bar-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 8px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
            overflow: hidden;
            display: none;
        }
        .powerup-bar-container.active { display: block; }
        .powerup-bar {
            height: 100%;
            transition: width 0.1s linear;
            border-radius: 4px;
        }
        .powerup-bar.speed { background: linear-gradient(90deg, #ffff00, #ff8800); }
        .powerup-bar.shield { background: linear-gradient(90deg, #00ffff, #0088ff); }
        .powerup-bar.multiplier { background: linear-gradient(90deg, #ff00ff, #ff0088); }

        /* Countdown overlay */
        .countdown-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 100;
        }
        .countdown-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 120px;
            font-weight: 900;
            color: var(--neon-cyan);
            text-shadow: 0 0 50px var(--neon-cyan);
            animation: countdownPulse 1s ease-out;
        }
        @keyframes countdownPulse {
            0% { transform: scale(2); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* Death animation */
        .death-flash {
            animation: deathFlash 0.5s ease-out;
        }
        @keyframes deathFlash {
            0%, 20%, 40%, 60%, 80%, 100% { filter: none; }
            10%, 30%, 50%, 70%, 90% { filter: brightness(3) saturate(0); }
        }

        /* Speed indicator */
        .speed-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 8px;
            color: var(--neon-yellow);
            text-shadow: 0 0 5px var(--neon-yellow);
        }

        /* Combo display */
        .combo-display {
            position: absolute;
            top: 30px;
            right: 10px;
            font-size: 10px;
            color: var(--neon-orange);
            text-shadow: 0 0 10px var(--neon-orange);
            display: none;
        }
        .combo-display.active { display: block; animation: comboPop 0.3s ease-out; }
        @keyframes comboPop { 0% { transform: scale(1.5); } 100% { transform: scale(1); } }

        /* Minimap */
        .minimap {
            position: absolute;
            bottom: 25px;
            right: 10px;
            width: 80px;
            height: 80px;
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--neon-cyan);
            border-radius: 5px;
            display: none;
        }
        .minimap.active { display: block; }

        /* Stats/Achievements modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-overlay.active { display: flex; }
        .modal-content {
            background: linear-gradient(145deg, #0d0d0d, #1a1a1a);
            border: 2px solid var(--neon-pink);
            border-radius: 15px;
            padding: 25px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(255,0,255,0.3);
        }
        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: var(--neon-pink);
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 15px var(--neon-pink);
        }
        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            background: none;
            border: none;
        }

        /* Achievement item */
        .achievement-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid #333;
        }
        .achievement-item.unlocked { border-color: var(--neon-green); background: rgba(0,255,0,0.1); }
        .achievement-icon { font-size: 24px; }
        .achievement-info { flex: 1; }
        .achievement-name { font-size: 9px; color: #fff; margin-bottom: 4px; }
        .achievement-desc { font-size: 7px; color: #888; }

        /* Stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .stat-card {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #333;
        }
        .stat-card-value {
            font-size: 16px;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        .stat-card-label {
            font-size: 7px;
            color: #888;
            margin-top: 5px;
        }

        /* Confirm dialog */
        .confirm-dialog {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 2px solid var(--neon-red);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        .confirm-dialog.active { display: block; }
        .confirm-text { color: #fff; font-size: 10px; margin-bottom: 15px; }

        /* Key bindings display */
        .keybind-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .keybind-action { color: #aaa; font-size: 8px; }
        .keybind-key {
            padding: 5px 10px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: var(--neon-cyan);
            font-size: 8px;
            cursor: pointer;
        }
        .keybind-key.listening { border-color: var(--neon-pink); animation: pulse 0.5s infinite; }

        /* Daily challenge banner */
        .daily-challenge-banner {
            background: linear-gradient(90deg, rgba(255,0,255,0.2), rgba(0,255,255,0.2));
            border: 1px solid var(--neon-pink);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            text-align: center;
        }
        .daily-challenge-title { font-size: 8px; color: var(--neon-pink); margin-bottom: 5px; }
        .daily-challenge-desc { font-size: 7px; color: #aaa; }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
        }
        .toast {
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--neon-green);
            border-radius: 8px;
            padding: 12px 20px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease-out;
        }
        .toast-achievement { border-color: var(--neon-yellow); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    </style>
</head>
<body>
    <!-- Colorblind filters -->
    <svg style="display:none">
        <defs>
            <filter id="deuteranopia-filter"><feColorMatrix type="matrix" values="0.625 0.375 0 0 0  0.7 0.3 0 0 0  0 0.3 0.7 0 0  0 0 0 1 0"/></filter>
            <filter id="protanopia-filter"><feColorMatrix type="matrix" values="0.567 0.433 0 0 0  0.558 0.442 0 0 0  0 0.242 0.758 0 0  0 0 0 1 0"/></filter>
            <filter id="tritanopia-filter"><feColorMatrix type="matrix" values="0.95 0.05 0 0 0  0 0.433 0.567 0 0  0 0.475 0.525 0 0  0 0 0 1 0"/></filter>
        </defs>
    </svg>

    <!-- Toast notifications container -->
    <div class="toast-container" id="toastContainer" aria-live="polite"></div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="statsModal" role="dialog" aria-labelledby="statsModalTitle">
        <div class="modal-content" style="position:relative;">
            <button class="modal-close" id="statsModalClose" aria-label="Close">&times;</button>
            <div class="modal-title" id="statsModalTitle">STATISTICS</div>
            <div class="stats-grid" id="statsGrid"></div>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div class="modal-overlay" id="achievementsModal" role="dialog" aria-labelledby="achievementsModalTitle">
        <div class="modal-content" style="position:relative;">
            <button class="modal-close" id="achievementsModalClose" aria-label="Close">&times;</button>
            <div class="modal-title" id="achievementsModalTitle">ACHIEVEMENTS</div>
            <div id="achievementsList"></div>
        </div>
    </div>

    <!-- Key Bindings Modal -->
    <div class="modal-overlay" id="keybindsModal" role="dialog" aria-labelledby="keybindsModalTitle">
        <div class="modal-content" style="position:relative;">
            <button class="modal-close" id="keybindsModalClose" aria-label="Close">&times;</button>
            <div class="modal-title" id="keybindsModalTitle">KEY BINDINGS</div>
            <div id="keybindsList"></div>
            <button class="btn btn-small" id="resetKeybindsBtn" style="margin-top:15px;background:#333;color:#fff;">RESET TO DEFAULT</button>
        </div>
    </div>

    <div class="game-container" id="gameContainer" role="main" aria-label="Snake Game">
        <div class="left-panel">
            <h1 class="title">SNAKEY SNACKS</h1>

            <div class="panel-section">
                <h3>PLAYER</h3>
                <input type="text" class="player-input" id="playerName" placeholder="Enter name..." maxlength="12">
            </div>

            <div class="panel-section green">
                <h3>STATS</h3>
                <div class="stat-row">
                    <span class="stat-label">SCORE</span>
                    <span class="stat-value score-value" id="currentScore">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">HIGH SCORE</span>
                    <span class="stat-value high-score-value" id="highScore">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">LEVEL</span>
                    <span class="stat-value level-value" id="currentLevel">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">LENGTH</span>
                    <span class="stat-value length-value" id="snakeLength">3</span>
                </div>
                <div class="stat-row" id="timerRow" style="display: none;">
                    <span class="stat-label">TIME</span>
                    <span class="stat-value time-value" id="timeLeft">60</span>
                </div>
                <div class="timer-bar-container" id="timerBarContainer" style="display: none;">
                    <div class="timer-bar" id="timerBar"></div>
                </div>
            </div>

            <div class="panel-section yellow">
                <h3>CONTROLS</h3>
                <div style="font-size: 7px; color: #666; line-height: 1.6; text-align: center;">
                    WASD / ARROWS - Move<br>
                    SPACE - Pause<br>
                    R - Quick Restart<br>
                    F - Fullscreen<br>
                    M - Toggle Music<br>
                    ESC - Menu
                </div>
            </div>

            <div class="panel-section pink">
                <h3>FOOD TYPES</h3>
                <div class="food-legend">
                    <div class="food-item">
                        <div class="food-icon" style="background: #00ff00;">A</div>
                        <span>Apple - 10 pts</span>
                    </div>
                    <div class="food-item">
                        <div class="food-icon" style="background: #ff0066;">C</div>
                        <span>Cherry - 25 pts</span>
                    </div>
                    <div class="food-item">
                        <div class="food-icon" style="background: #ffd700;">G</div>
                        <span>Gold - 50 pts</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="game-area">
            <div class="canvas-container" id="canvasContainer">
                <canvas id="gameCanvas" width="500" height="500" role="img" aria-label="Game canvas"></canvas>

                <!-- In-game HUD -->
                <div class="speed-indicator" id="speedIndicator">SPEED: 100%</div>
                <div class="combo-display" id="comboDisplay">COMBO x1</div>
                <div class="powerup-bar-container" id="powerupBarContainer">
                    <div class="powerup-bar" id="powerupBar"></div>
                </div>
                <canvas class="minimap" id="minimapCanvas" width="80" height="80"></canvas>

                <!-- Countdown overlay -->
                <div class="countdown-overlay" id="countdownOverlay" style="display:none;">
                    <div class="countdown-number" id="countdownNumber">3</div>
                </div>

                <!-- Confirm exit dialog -->
                <div class="confirm-dialog" id="confirmExitDialog">
                    <div class="confirm-text">Exit to menu?<br>Progress will be lost!</div>
                    <div style="display:flex;gap:10px;justify-content:center;">
                        <button type="button" class="btn btn-small btn-primary" id="confirmExitYes">YES</button>
                        <button type="button" class="btn btn-small btn-secondary" id="confirmExitNo">NO</button>
                    </div>
                </div>

                <!-- Main Menu Overlay -->
                <div class="game-overlay" id="menuOverlay">
                    <div class="overlay-title">SNAKEY SNACKS</div>

                    <!-- Daily Challenge Banner -->
                    <div class="daily-challenge-banner" id="dailyChallengeBanner">
                        <div class="daily-challenge-title">DAILY CHALLENGE</div>
                        <div class="daily-challenge-desc" id="dailyChallengeDesc">Score 500 points in Timed mode!</div>
                    </div>

                    <div class="overlay-subtitle">Select Game Mode</div>

                    <div class="menu-grid">
                        <div class="menu-btn selected" data-mode="classic">
                            <div class="menu-btn-title">CLASSIC</div>
                            <div class="menu-btn-desc">Traditional snake gameplay</div>
                        </div>
                        <div class="menu-btn" data-mode="timed">
                            <div class="menu-btn-title">TIMED</div>
                            <div class="menu-btn-desc">Race against the clock</div>
                        </div>
                        <div class="menu-btn" data-mode="maze">
                            <div class="menu-btn-title">MAZE</div>
                            <div class="menu-btn-desc">Navigate through obstacles</div>
                        </div>
                        <div class="menu-btn" data-mode="endless">
                            <div class="menu-btn-title">ENDLESS</div>
                            <div class="menu-btn-desc">No walls, wrap around</div>
                        </div>
                    </div>

                    <div class="overlay-subtitle" style="margin-top: 15px;">Difficulty</div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-small toggle-btn" data-difficulty="easy">EASY</button>
                        <button class="btn btn-small toggle-btn active" data-difficulty="medium">MEDIUM</button>
                        <button class="btn btn-small toggle-btn" data-difficulty="hard">HARD</button>
                    </div>

                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="btn btn-primary" id="startBtn">START GAME</button>
                        <button class="btn btn-secondary" id="tutorialBtn">TUTORIAL</button>
                    </div>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:5px;">
                        <button type="button" class="btn btn-small" id="settingsBtn" style="background:#333;color:#fff;">SETTINGS</button>
                        <button type="button" class="btn btn-small" id="statsBtn" style="background:#333;color:#fff;">STATS</button>
                        <button type="button" class="btn btn-small" id="achievementsBtn" style="background:#333;color:#fff;">ACHIEVEMENTS</button>
                    </div>
                </div>

                <!-- Tutorial Overlay -->
                <div class="game-overlay hidden" id="tutorialOverlay">
                    <div class="tutorial-step" id="tutorialStep">
                        <!-- Content populated by JS -->
                    </div>
                    <div class="tutorial-dots" id="tutorialDots"></div>
                    <div class="tutorial-nav">
                        <button class="btn btn-small btn-secondary" id="tutorialPrev">BACK</button>
                        <button class="btn btn-small btn-primary" id="tutorialNext">NEXT</button>
                    </div>
                </div>

                <!-- Settings Overlay -->
                <div class="game-overlay hidden" id="settingsOverlay">
                    <div class="overlay-title" style="font-size: 20px;">SETTINGS</div>

                    <div style="width: 100%; max-width: 350px;">
                        <div class="settings-row">
                            <span class="settings-label">SHOW GRID</span>
                            <div class="settings-control">
                                <button class="toggle-btn active" data-setting="grid" data-value="on">ON</button>
                                <button class="toggle-btn" data-setting="grid" data-value="off">OFF</button>
                            </div>
                        </div>

                        <div class="settings-row">
                            <span class="settings-label">SOUND</span>
                            <div class="settings-control">
                                <button class="toggle-btn active" data-setting="sound" data-value="on">ON</button>
                                <button class="toggle-btn" data-setting="sound" data-value="off">OFF</button>
                            </div>
                        </div>

                        <div class="settings-row">
                            <span class="settings-label">VOLUME</span>
                            <div class="slider-container">
                                <input type="range" class="slider" id="volumeSlider" min="0" max="100" value="50">
                                <span class="slider-value" id="volumeValue">50%</span>
                            </div>
                        </div>

                        <div class="settings-row">
                            <span class="settings-label">TRAIL EFFECT</span>
                            <div class="settings-control">
                                <button class="toggle-btn active" data-setting="trail" data-value="on">ON</button>
                                <button class="toggle-btn" data-setting="trail" data-value="off">OFF</button>
                            </div>
                        </div>

                        <div class="settings-row">
                            <span class="settings-label">SMOOTH MOVEMENT</span>
                            <div class="settings-control">
                                <button class="toggle-btn active" data-setting="smooth" data-value="on">ON</button>
                                <button class="toggle-btn" data-setting="smooth" data-value="off">OFF</button>
                            </div>
                        </div>

                        <div style="margin-top: 15px;">
                            <span class="settings-label">SNAKE SKIN</span>
                            <div class="selection-row">
                                <div class="skin-btn skin-classic selected" data-skin="classic" title="Classic"></div>
                                <div class="skin-btn skin-rainbow" data-skin="rainbow" title="Rainbow"></div>
                                <div class="skin-btn skin-fire" data-skin="fire" title="Fire"></div>
                                <div class="skin-btn skin-ice" data-skin="ice" title="Ice"></div>
                                <div class="skin-btn skin-pixel" data-skin="pixel" title="Pixel"></div>
                            </div>
                        </div>

                        <div style="margin-top: 15px;">
                            <span class="settings-label">BACKGROUND THEME</span>
                            <div class="selection-row">
                                <div class="theme-btn theme-default selected" data-theme="default" title="Default"></div>
                                <div class="theme-btn theme-space" data-theme="space" title="Space"></div>
                                <div class="theme-btn theme-forest" data-theme="forest" title="Forest"></div>
                                <div class="theme-btn theme-underwater" data-theme="underwater" title="Underwater"></div>
                            </div>
                        </div>

                        <!-- Accessibility Settings -->
                        <div style="margin-top:20px;padding-top:15px;border-top:1px solid #333;">
                            <span class="settings-label" style="color:var(--neon-pink);">ACCESSIBILITY</span>

                            <div class="settings-row">
                                <span class="settings-label">HIGH CONTRAST</span>
                                <div class="settings-control">
                                    <button type="button" class="toggle-btn" data-setting="highContrast" data-value="on">ON</button>
                                    <button type="button" class="toggle-btn active" data-setting="highContrast" data-value="off">OFF</button>
                                </div>
                            </div>

                            <div class="settings-row">
                                <span class="settings-label">REDUCED MOTION</span>
                                <div class="settings-control">
                                    <button type="button" class="toggle-btn" data-setting="reducedMotion" data-value="on">ON</button>
                                    <button type="button" class="toggle-btn active" data-setting="reducedMotion" data-value="off">OFF</button>
                                </div>
                            </div>

                            <div class="settings-row">
                                <span class="settings-label">COLORBLIND MODE</span>
                                <div class="settings-control">
                                    <button type="button" class="toggle-btn active" data-setting="colorblind" data-value="none">NONE</button>
                                    <button type="button" class="toggle-btn" data-setting="colorblind" data-value="deuteranopia">D</button>
                                    <button type="button" class="toggle-btn" data-setting="colorblind" data-value="protanopia">P</button>
                                    <button type="button" class="toggle-btn" data-setting="colorblind" data-value="tritanopia">T</button>
                                </div>
                            </div>

                            <div class="settings-row">
                                <span class="settings-label">SHOW MINIMAP</span>
                                <div class="settings-control">
                                    <button type="button" class="toggle-btn" data-setting="minimap" data-value="on">ON</button>
                                    <button type="button" class="toggle-btn active" data-setting="minimap" data-value="off">OFF</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="display:flex;gap:10px;margin-top:15px;flex-wrap:wrap;justify-content:center;">
                        <button type="button" class="btn btn-primary" id="settingsBackBtn">BACK TO MENU</button>
                        <button type="button" class="btn btn-small" id="keybindsBtn" style="background:#333;color:#fff;">KEY BINDINGS</button>
                        <button type="button" class="btn btn-small" id="exportBtn" style="background:#333;color:#fff;">EXPORT</button>
                        <button type="button" class="btn btn-small" id="importBtn" style="background:#333;color:#fff;">IMPORT</button>
                        <button type="button" class="btn btn-small" id="resetProgressBtn" style="background:#ff0044;color:#fff;">RESET ALL</button>
                    </div>
                </div>

                <!-- Pause Overlay -->
                <div class="game-overlay hidden" id="pauseOverlay">
                    <div class="overlay-title">PAUSED</div>
                    <div class="overlay-subtitle">Press SPACE to continue</div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-secondary" id="resumeBtn">RESUME</button>
                        <button class="btn btn-small" id="pauseMenuBtn" style="background: #333; color: #fff;">MENU</button>
                    </div>
                </div>

                <!-- Game Over Overlay -->
                <div class="game-overlay hidden" id="gameOverOverlay">
                    <div class="overlay-title" id="gameOverTitle">GAME OVER</div>
                    <div class="overlay-score" id="finalScore">Score: 0</div>
                    <div class="overlay-subtitle" id="gameOverStats" style="font-size:8px;color:#888;margin:5px 0;">Level: 1 | Length: 3</div>
                    <div class="overlay-subtitle" id="newHighScore" style="display:none;color:var(--neon-yellow);">NEW HIGH SCORE!</div>
                    <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;">
                        <button type="button" class="btn btn-primary" id="restartBtn">PLAY AGAIN</button>
                        <button type="button" class="btn btn-secondary" id="gameOverMenuBtn">MENU</button>
                        <button type="button" class="btn btn-small" id="shareScoreBtn" style="background:#333;color:#fff;">SHARE</button>
                    </div>
                </div>

                <!-- Boss Level Overlay -->
                <div class="game-overlay hidden" id="bossOverlay">
                    <div class="overlay-title" style="color: var(--neon-red);">BOSS LEVEL!</div>
                    <div class="overlay-subtitle">Survive the challenge!</div>
                    <div class="overlay-score" id="bossObjective">Collect 5 golden fruits</div>
                    <button class="btn btn-primary" id="bossStartBtn">BEGIN</button>
                </div>
            </div>

            <div class="game-buttons">
                <button class="btn btn-secondary btn-small" id="pauseBtn">PAUSE</button>
                <button class="btn btn-small" id="fullscreenBtn" style="background: #333; color: #fff;">FULLSCREEN</button>
            </div>

            <div class="touch-controls">
                <button class="btn btn-small" id="touchUp">UP</button>
                <button class="btn btn-small" id="touchLeft">LEFT</button>
                <button class="btn btn-small" id="touchDown">DOWN</button>
                <button class="btn btn-small" id="touchRight">RIGHT</button>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel-section orange">
                <h3>LEADERBOARD</h3>
                <div class="leaderboard-list" id="leaderboardList">
                    <div style="text-align: center; color: #666; font-size: 7px;">No scores yet</div>
                </div>
            </div>

            <div class="panel-section pink">
                <h3>POWER-UPS</h3>
                <div class="food-legend">
                    <div class="food-item">
                        <div class="food-icon" style="background: var(--neon-yellow);">S</div>
                        <span>Speed Boost</span>
                    </div>
                    <div class="food-item">
                        <div class="food-icon" style="background: var(--neon-cyan);">I</div>
                        <span>Invincibility</span>
                    </div>
                    <div class="food-item">
                        <div class="food-icon" style="background: var(--neon-pink);">x2</div>
                        <span>Score Multiplier</span>
                    </div>
                </div>
            </div>

            <div class="panel-section" id="modeInfoPanel">
                <h3>GAME MODE</h3>
                <div style="font-size: 8px; color: var(--neon-cyan);" id="currentModeDisplay">CLASSIC</div>
                <div style="font-size: 7px; color: #666; margin-top: 5px;" id="currentDiffDisplay">MEDIUM</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            CANVAS_SIZE: 500,
            GRID_SIZE: 20,
            CELL_SIZE: 25,
            DIFFICULTIES: {
                easy: { speed: 250, gridSize: 15, cellSize: 33.33 },
                medium: { speed: 180, gridSize: 20, cellSize: 25 },
                hard: { speed: 120, gridSize: 25, cellSize: 20 }
            },
            FOOD_TYPES: {
                apple: { points: 10, color: '#00ff00', char: 'A', chance: 0.7 },
                cherry: { points: 25, color: '#ff0066', char: 'C', chance: 0.2 },
                gold: { points: 50, color: '#ffd700', char: 'G', chance: 0.1 }
            },
            POWERUP_DURATION: 5000,
            POWERUP_SPAWN_CHANCE: 0.12,
            TIMED_MODE_DURATION: 60,
            BOSS_LEVEL_INTERVAL: 5,
            COMBO_TIMEOUT: 2000,
            MAX_SPAWN_ATTEMPTS: 100
        };

        // ==================== ACHIEVEMENTS ====================
        const ACHIEVEMENTS = [
            { id: 'first_game', name: 'First Steps', desc: 'Play your first game', icon: '', check: s => s.gamesPlayed >= 1 },
            { id: 'score_100', name: 'Century', desc: 'Score 100 points', icon: '', check: s => s.highScore >= 100 },
            { id: 'score_500', name: 'High Roller', desc: 'Score 500 points', icon: '', check: s => s.highScore >= 500 },
            { id: 'score_1000', name: 'Legendary', desc: 'Score 1000 points', icon: '', check: s => s.highScore >= 1000 },
            { id: 'length_20', name: 'Long Boy', desc: 'Reach length 20', icon: '', check: s => s.maxLength >= 20 },
            { id: 'length_50', name: 'Anaconda', desc: 'Reach length 50', icon: '', check: s => s.maxLength >= 50 },
            { id: 'combo_5', name: 'Combo Starter', desc: 'Get a 5x combo', icon: '', check: s => s.maxCombo >= 5 },
            { id: 'combo_10', name: 'Combo Master', desc: 'Get a 10x combo', icon: '', check: s => s.maxCombo >= 10 },
            { id: 'games_10', name: 'Dedicated', desc: 'Play 10 games', icon: '', check: s => s.gamesPlayed >= 10 },
            { id: 'games_50', name: 'Addicted', desc: 'Play 50 games', icon: '', check: s => s.gamesPlayed >= 50 },
            { id: 'powerups_10', name: 'Power Hungry', desc: 'Collect 10 power-ups', icon: '', check: s => s.powerupsCollected >= 10 },
            { id: 'boss_1', name: 'Boss Slayer', desc: 'Complete a boss level', icon: '', check: s => s.bossesDefeated >= 1 },
            { id: 'daily_1', name: 'Daily Player', desc: 'Complete a daily challenge', icon: '', check: s => s.dailiesCompleted >= 1 },
            { id: 'speed_demon', name: 'Speed Demon', desc: 'Win on Hard difficulty', icon: '', check: s => s.hardWins >= 1 },
            { id: 'survivor', name: 'Survivor', desc: 'Survive 5 minutes in Endless', icon: '', check: s => s.longestSurvival >= 300 }
        ];

        // ==================== DAILY CHALLENGES ====================
        const DAILY_CHALLENGES = [
            { desc: 'Score 500 points in Timed mode', mode: 'timed', target: 500, type: 'score' },
            { desc: 'Reach length 30 in Classic mode', mode: 'classic', target: 30, type: 'length' },
            { desc: 'Collect 5 gold fruits in one game', mode: 'any', target: 5, type: 'gold' },
            { desc: 'Get a 7x combo', mode: 'any', target: 7, type: 'combo' },
            { desc: 'Score 300 points in Maze mode', mode: 'maze', target: 300, type: 'score' },
            { desc: 'Survive 3 minutes in Endless', mode: 'endless', target: 180, type: 'time' },
            { desc: 'Complete a boss level', mode: 'classic', target: 1, type: 'boss' }
        ];

        // ==================== DEFAULT KEY BINDINGS ====================
        const DEFAULT_KEYBINDS = {
            up: ['w', 'arrowup'],
            down: ['s', 'arrowdown'],
            left: ['a', 'arrowleft'],
            right: ['d', 'arrowright'],
            pause: [' '],
            restart: ['r'],
            fullscreen: ['f'],
            menu: ['escape'],
            music: ['m']
        };

        // ==================== TUTORIAL DATA ====================
        const TUTORIAL_STEPS = [
            {
                icon: '',
                title: 'Welcome to Snakey Snacks!',
                text: 'Guide your snake to eat food and grow longer. Avoid hitting walls and yourself!'
            },
            {
                icon: '',
                title: 'Controls',
                text: 'Use WASD or Arrow Keys to move. Press SPACE to pause. Press F for fullscreen.',
                showKeys: true
            },
            {
                icon: '',
                title: 'Food Types',
                text: 'Apples (10pts) are common. Cherries (25pts) are rare. Golden fruits (50pts) are legendary!'
            },
            {
                icon: '',
                title: 'Power-Ups',
                text: 'Collect power-ups for special abilities: Speed boost, Invincibility, and Score multiplier!'
            },
            {
                icon: '',
                title: 'Game Modes',
                text: 'Classic: Traditional gameplay. Timed: Beat the clock. Maze: Avoid obstacles. Endless: No walls!'
            },
            {
                icon: '',
                title: 'Boss Levels',
                text: 'Every 5 levels, face a boss challenge! Complete special objectives to continue.'
            },
            {
                icon: '',
                title: 'Ready to Play?',
                text: 'Your scores are saved locally. Compete for the top of the leaderboard!'
            }
        ];

        // ==================== AUDIO SYSTEM ====================
        class AudioSystem {
            constructor() {
                this.muted = false;
                this.volume = 0.5;
                this.audioContext = null;
                this.musicPlaying = false;
                this.musicNodes = [];
            }

            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            setVolume(vol) {
                this.volume = vol / 100;
            }

            playTone(frequency, duration, type = 'square') {
                if (this.muted || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(this.volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            eat(foodType) {
                const freqs = {
                    apple: [587.33, 880],
                    cherry: [659.25, 987.77],
                    gold: [783.99, 1174.66, 1567.98]
                };
                (freqs[foodType] || freqs.apple).forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.1), i * 50);
                });
            }

            powerUp() {
                [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.15, 'sine'), i * 75);
                });
            }

            gameOver() {
                [392, 349.23, 329.63, 293.66].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.3, 'sawtooth'), i * 150);
                });
            }

            levelUp() {
                [523.25, 659.25, 783.99, 1046.5, 1318.51].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.2, 'sine'), i * 100);
                });
            }

            bossAlert() {
                [196, 196, 246.94, 196, 174.61, 164.81].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.2, 'sawtooth'), i * 200);
                });
            }

            countdown(num) {
                const freq = num === 0 ? 880 : 440;
                this.playTone(freq, 0.2, 'sine');
            }

            combo(count) {
                const baseFreq = 400 + count * 50;
                this.playTone(baseFreq, 0.1, 'sine');
            }

            achievement() {
                [523.25, 659.25, 783.99, 1046.5, 1318.51, 1567.98].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.15, 'sine'), i * 80);
                });
            }

            toggleMusic() {
                if (!this.audioContext) this.init();
                if (this.musicPlaying) {
                    this.stopMusic();
                } else {
                    this.startMusic();
                }
                return this.musicPlaying;
            }

            startMusic() {
                if (this.muted || !this.audioContext || this.musicPlaying) return;
                this.musicPlaying = true;
                this.playMusicLoop();
            }

            stopMusic() {
                this.musicPlaying = false;
                this.musicNodes.forEach(node => {
                    try { node.stop(); } catch(e) {}
                });
                this.musicNodes = [];
            }

            playMusicLoop() {
                if (!this.musicPlaying || !this.audioContext) return;

                const notes = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];
                const pattern = [0, 2, 4, 5, 4, 2, 0, 2, 4, 7, 5, 4, 2, 0];
                const tempo = 200;

                pattern.forEach((noteIdx, i) => {
                    setTimeout(() => {
                        if (!this.musicPlaying) return;
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        osc.frequency.value = notes[noteIdx];
                        osc.type = 'triangle';
                        gain.gain.setValueAtTime(this.volume * 0.08, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.15);
                        this.musicNodes.push(osc);
                    }, i * tempo);
                });

                setTimeout(() => {
                    if (this.musicPlaying) this.playMusicLoop();
                }, pattern.length * tempo);
            }
        }

        // ==================== PARTICLE SYSTEM ====================
        class ParticleSystem {
            constructor(container) {
                this.container = container;
            }

            emit(x, y, color, count = 8) {
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.width = '8px';
                    particle.style.height = '8px';
                    particle.style.background = color;
                    particle.style.boxShadow = `0 0 10px ${color}`;

                    const angle = (Math.PI * 2 / count) * i;
                    const velocity = 50 + Math.random() * 30;
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity;

                    particle.style.transform = `translate(${dx}px, ${dy}px)`;
                    this.container.appendChild(particle);
                    setTimeout(() => particle.remove(), 500);
                }
            }

            trail(x, y, color) {
                const trail = document.createElement('div');
                trail.className = 'trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                trail.style.width = '12px';
                trail.style.height = '12px';
                trail.style.background = color;
                trail.style.boxShadow = `0 0 8px ${color}`;
                this.container.appendChild(trail);
                setTimeout(() => trail.remove(), 300);
            }
        }

        // ==================== MAIN GAME CLASS ====================
        class SnakeGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('gameContainer');
                this.canvasContainer = document.getElementById('canvasContainer');
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.audio = new AudioSystem();
                this.particles = new ParticleSystem(this.canvasContainer);

                // Game state
                this.state = 'menu';
                this.gameMode = 'classic';
                this.difficulty = 'medium';

                // Settings
                this.settings = {
                    showGrid: true,
                    sound: true,
                    volume: 50,
                    trail: true,
                    smooth: true,
                    skin: 'classic',
                    theme: 'default',
                    highContrast: false,
                    reducedMotion: false,
                    colorblind: 'none',
                    minimap: false,
                    music: false
                };

                // Key bindings
                this.keybinds = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));
                this.listeningForKey = null;

                // Snake state
                this.snake = [];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.inputBuffer = []; // Input buffer for queued moves
                this.visualSnake = [];

                // Game objects
                this.food = null;
                this.powerUp = null;
                this.obstacles = [];
                this.powerUpActive = null;
                this.powerUpTimer = null;
                this.powerUpStartTime = 0;
                this.powerUpPausedTime = 0;

                // Stats
                this.score = 0;
                this.highScore = 0;
                this.level = 1;
                this.scoreMultiplier = 1;
                this.isInvincible = false;
                this.baseSpeed = CONFIG.DIFFICULTIES.medium.speed;

                // Combo system
                this.combo = 0;
                this.lastEatTime = 0;
                this.comboTimer = null;
                this.goldCollected = 0;

                // Timing
                this.speed = CONFIG.DIFFICULTIES.medium.speed;
                this.gridSize = CONFIG.DIFFICULTIES.medium.gridSize;
                this.cellSize = CONFIG.DIFFICULTIES.medium.cellSize;
                this.gameLoop = null;
                this.lastUpdate = 0;
                this.interpolation = 0;
                this.gameStartTime = 0;

                // Timed mode
                this.timeLeft = CONFIG.TIMED_MODE_DURATION;
                this.timerInterval = null;

                // Boss mode
                this.isBossLevel = false;
                this.bossObjective = 0;
                this.bossProgress = 0;

                // Player
                this.playerName = 'PLAYER';
                this.leaderboard = [];

                // Tutorial
                this.tutorialStep = 0;

                // Statistics
                this.stats = {
                    gamesPlayed: 0,
                    highScore: 0,
                    totalScore: 0,
                    maxLength: 0,
                    maxCombo: 0,
                    powerupsCollected: 0,
                    bossesDefeated: 0,
                    dailiesCompleted: 0,
                    hardWins: 0,
                    longestSurvival: 0,
                    foodEaten: 0,
                    totalPlayTime: 0
                };

                // Achievements
                this.unlockedAchievements = [];

                // Daily challenge
                this.dailyChallenge = null;
                this.dailyChallengeCompleted = false;
                this.lastDailyDate = null;

                // Ghost mode (shows previous best run)
                this.ghostMode = false;
                this.ghostData = [];
                this.currentRunData = [];

                this.init();
            }

            init() {
                this.loadData();
                this.setupEventListeners();
                this.updateUI();
                this.renderMenu();
            }

            loadData() {
                try {
                    const saved = localStorage.getItem('snakeySnacksData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.highScore = data.highScore || 0;
                        this.leaderboard = data.leaderboard || [];
                        this.playerName = data.playerName || 'PLAYER';
                        this.settings = { ...this.settings, ...data.settings };
                        this.stats = { ...this.stats, ...data.stats };
                        this.unlockedAchievements = data.unlockedAchievements || [];
                        this.keybinds = { ...this.keybinds, ...data.keybinds };
                        this.lastDailyDate = data.lastDailyDate || null;
                        this.ghostData = data.ghostData || [];
                    }
                } catch (e) {}

                document.getElementById('playerName').value = this.playerName;
                this.applySettings();
                this.updateLeaderboard();
                this.initDailyChallenge();
            }

            saveData() {
                try {
                    localStorage.setItem('snakeySnacksData', JSON.stringify({
                        highScore: this.highScore,
                        leaderboard: this.leaderboard,
                        playerName: this.playerName,
                        settings: this.settings,
                        stats: this.stats,
                        unlockedAchievements: this.unlockedAchievements,
                        keybinds: this.keybinds,
                        lastDailyDate: this.lastDailyDate,
                        ghostData: this.ghostData
                    }));
                } catch (e) {}
            }

            exportData() {
                const data = {
                    highScore: this.highScore,
                    leaderboard: this.leaderboard,
                    playerName: this.playerName,
                    settings: this.settings,
                    stats: this.stats,
                    unlockedAchievements: this.unlockedAchievements,
                    keybinds: this.keybinds
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'snakey-snacks-save.json';
                a.click();
                URL.revokeObjectURL(url);
                this.showToast('Data exported!');
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            this.highScore = data.highScore || 0;
                            this.leaderboard = data.leaderboard || [];
                            this.playerName = data.playerName || 'PLAYER';
                            this.settings = { ...this.settings, ...data.settings };
                            this.stats = { ...this.stats, ...data.stats };
                            this.unlockedAchievements = data.unlockedAchievements || [];
                            this.keybinds = { ...this.keybinds, ...data.keybinds };
                            this.saveData();
                            this.applySettings();
                            this.updateLeaderboard();
                            document.getElementById('playerName').value = this.playerName;
                            this.showToast('Data imported!');
                        } catch (err) {
                            this.showToast('Invalid save file!');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            resetProgress() {
                if (confirm('Are you sure you want to reset ALL progress? This cannot be undone!')) {
                    localStorage.removeItem('snakeySnacksData');
                    location.reload();
                }
            }

            initDailyChallenge() {
                const today = new Date().toDateString();
                if (this.lastDailyDate !== today) {
                    // New day, new challenge
                    const seed = new Date().getDate() + new Date().getMonth() * 31;
                    this.dailyChallenge = DAILY_CHALLENGES[seed % DAILY_CHALLENGES.length];
                    this.dailyChallengeCompleted = false;
                    this.lastDailyDate = today;
                    this.saveData();
                }
                document.getElementById('dailyChallengeDesc').textContent = this.dailyChallenge?.desc || 'Complete today\'s challenge!';
            }

            showToast(message, type = 'default') {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = 'toast' + (type === 'achievement' ? ' toast-achievement' : '');
                const color = type === 'achievement' ? 'var(--neon-yellow)' : 'var(--neon-green)';
                toast.innerHTML = '<span style="color:' + color + ';font-size:9px;">' + this.escapeHtml(message) + '</span>';
                container.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            applySettings() {
                this.audio.muted = !this.settings.sound;
                this.audio.setVolume(this.settings.volume);

                // Build body classes
                const classes = [];
                if (this.settings.theme !== 'default') classes.push('theme-' + this.settings.theme);
                if (this.settings.highContrast) classes.push('high-contrast');
                if (this.settings.reducedMotion) classes.push('reduced-motion');
                if (this.settings.colorblind !== 'none') classes.push('colorblind-' + this.settings.colorblind);
                document.body.className = classes.join(' ');

                // Minimap
                document.getElementById('minimapCanvas').classList.toggle('active', this.settings.minimap);

                // Update UI toggles
                document.querySelectorAll('[data-setting]').forEach(btn => {
                    const setting = btn.dataset.setting;
                    const value = btn.dataset.value;
                    if (setting === 'grid') btn.classList.toggle('active', (value === 'on') === this.settings.showGrid);
                    if (setting === 'sound') btn.classList.toggle('active', (value === 'on') === this.settings.sound);
                    if (setting === 'trail') btn.classList.toggle('active', (value === 'on') === this.settings.trail);
                    if (setting === 'smooth') btn.classList.toggle('active', (value === 'on') === this.settings.smooth);
                    if (setting === 'highContrast') btn.classList.toggle('active', (value === 'on') === this.settings.highContrast);
                    if (setting === 'reducedMotion') btn.classList.toggle('active', (value === 'on') === this.settings.reducedMotion);
                    if (setting === 'minimap') btn.classList.toggle('active', (value === 'on') === this.settings.minimap);
                    if (setting === 'colorblind') btn.classList.toggle('active', value === this.settings.colorblind);
                });

                document.querySelectorAll('.skin-btn').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.skin === this.settings.skin);
                });

                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.theme === this.settings.theme);
                });

                document.getElementById('volumeSlider').value = this.settings.volume;
                document.getElementById('volumeValue').textContent = this.settings.volume + '%';
            }

            setupEventListeners() {
                // Keyboard
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));

                // Focus loss - auto pause
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.state === 'playing') {
                        this.pause();
                    }
                });

                window.addEventListener('blur', () => {
                    if (this.state === 'playing') {
                        this.pause();
                    }
                });

                // Menu buttons
                document.querySelectorAll('.menu-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.gameMode = btn.dataset.mode;
                        document.getElementById('currentModeDisplay').textContent = this.gameMode.toUpperCase();
                    });
                });

                document.querySelectorAll('[data-difficulty]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('[data-difficulty]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.difficulty = btn.dataset.difficulty;
                        document.getElementById('currentDiffDisplay').textContent = this.difficulty.toUpperCase();
                    });
                });

                // Game buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('tutorialBtn').addEventListener('click', () => this.showTutorial());
                document.getElementById('settingsBtn').addEventListener('click', () => this.showSettings());
                document.getElementById('settingsBackBtn').addEventListener('click', () => this.showMenu());
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('resumeBtn').addEventListener('click', () => this.resume());
                document.getElementById('pauseMenuBtn').addEventListener('click', () => this.showMenu());
                document.getElementById('restartBtn').addEventListener('click', () => this.startGame());
                document.getElementById('gameOverMenuBtn').addEventListener('click', () => this.showMenu());
                document.getElementById('bossStartBtn').addEventListener('click', () => this.startBossLevel());
                document.getElementById('fullscreenBtn').addEventListener('click', () => this.toggleFullscreen());

                // New buttons
                document.getElementById('statsBtn').addEventListener('click', () => this.showStatsModal());
                document.getElementById('achievementsBtn').addEventListener('click', () => this.showAchievementsModal());
                document.getElementById('statsModalClose').addEventListener('click', () => this.closeModal('statsModal'));
                document.getElementById('achievementsModalClose').addEventListener('click', () => this.closeModal('achievementsModal'));
                document.getElementById('keybindsModalClose').addEventListener('click', () => this.closeModal('keybindsModal'));
                document.getElementById('keybindsBtn').addEventListener('click', () => this.showKeybindsModal());
                document.getElementById('resetKeybindsBtn').addEventListener('click', () => this.resetKeybinds());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
                document.getElementById('importBtn').addEventListener('click', () => this.importData());
                document.getElementById('resetProgressBtn').addEventListener('click', () => this.resetProgress());
                document.getElementById('shareScoreBtn').addEventListener('click', () => this.shareScore());
                document.getElementById('confirmExitYes').addEventListener('click', () => this.confirmExit(true));
                document.getElementById('confirmExitNo').addEventListener('click', () => this.confirmExit(false));

                // Tutorial navigation
                document.getElementById('tutorialPrev').addEventListener('click', () => this.tutorialPrevStep());
                document.getElementById('tutorialNext').addEventListener('click', () => this.tutorialNextStep());

                // Settings controls
                document.querySelectorAll('[data-setting]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const setting = btn.dataset.setting;
                        const value = btn.dataset.value;
                        const boolValue = value === 'on';

                        document.querySelectorAll('[data-setting="' + setting + '"]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        if (setting === 'grid') this.settings.showGrid = boolValue;
                        if (setting === 'sound') { this.settings.sound = boolValue; this.audio.muted = !boolValue; }
                        if (setting === 'trail') this.settings.trail = boolValue;
                        if (setting === 'smooth') this.settings.smooth = boolValue;
                        if (setting === 'highContrast') this.settings.highContrast = boolValue;
                        if (setting === 'reducedMotion') this.settings.reducedMotion = boolValue;
                        if (setting === 'minimap') this.settings.minimap = boolValue;
                        if (setting === 'colorblind') this.settings.colorblind = value;

                        this.applySettings();
                        this.saveData();
                    });
                });

                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    this.settings.volume = parseInt(e.target.value);
                    this.audio.setVolume(this.settings.volume);
                    document.getElementById('volumeValue').textContent = this.settings.volume + '%';
                    this.saveData();
                });

                document.querySelectorAll('.skin-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.skin-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.settings.skin = btn.dataset.skin;
                        this.saveData();
                    });
                });

                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.settings.theme = btn.dataset.theme;
                        document.body.className = this.settings.theme !== 'default' ? `theme-${this.settings.theme}` : '';
                        this.saveData();
                    });
                });

                // Player name
                document.getElementById('playerName').addEventListener('change', (e) => {
                    this.playerName = e.target.value || 'PLAYER';
                    this.saveData();
                });

                // Touch controls
                document.getElementById('touchUp').addEventListener('click', () => this.setDirection(0, -1));
                document.getElementById('touchDown').addEventListener('click', () => this.setDirection(0, 1));
                document.getElementById('touchLeft').addEventListener('click', () => this.setDirection(-1, 0));
                document.getElementById('touchRight').addEventListener('click', () => this.setDirection(1, 0));

                // Swipe
                let touchStartX = 0, touchStartY = 0;
                this.canvas.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                this.canvas.addEventListener('touchend', (e) => {
                    const dx = e.changedTouches[0].clientX - touchStartX;
                    const dy = e.changedTouches[0].clientY - touchStartY;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        this.setDirection(dx > 0 ? 1 : -1, 0);
                    } else {
                        this.setDirection(0, dy > 0 ? 1 : -1);
                    }
                });
            }

            handleKeyDown(e) {
                // Handle keybind listening mode
                if (this.listeningForKey) {
                    e.preventDefault();
                    const key = e.key.toLowerCase();
                    if (key !== 'escape') {
                        this.keybinds[this.listeningForKey] = [key];
                        this.saveData();
                    }
                    this.listeningForKey = null;
                    this.renderKeybinds();
                    return;
                }

                const key = e.key.toLowerCase();

                // Check custom keybinds
                const isKey = (action) => this.keybinds[action]?.includes(key);

                // Global keys
                if (isKey('fullscreen')) {
                    e.preventDefault();
                    this.toggleFullscreen();
                    return;
                }

                if (isKey('menu')) {
                    e.preventDefault();
                    if (this.state === 'playing') {
                        this.showConfirmExit();
                    } else if (this.state !== 'menu') {
                        this.showMenu();
                    }
                    return;
                }

                if (isKey('music')) {
                    e.preventDefault();
                    this.audio.toggleMusic();
                    this.showToast(this.audio.musicPlaying ? 'Music ON' : 'Music OFF');
                    return;
                }

                if (isKey('pause')) {
                    e.preventDefault();
                    if (this.state === 'playing') this.pause();
                    else if (this.state === 'paused') this.resume();
                    else if (this.state === 'menu') this.startGame();
                    return;
                }

                if (isKey('restart')) {
                    e.preventDefault();
                    if (this.state === 'playing' || this.state === 'paused' || this.state === 'gameover') {
                        this.startGame();
                    }
                    return;
                }

                if (key === 'enter' && this.state === 'menu') {
                    e.preventDefault();
                    this.startGame();
                    return;
                }

                // Movement with input buffer
                if (this.state !== 'playing') return;

                if (isKey('up')) { e.preventDefault(); this.bufferDirection(0, -1); }
                else if (isKey('down')) { e.preventDefault(); this.bufferDirection(0, 1); }
                else if (isKey('left')) { e.preventDefault(); this.bufferDirection(-1, 0); }
                else if (isKey('right')) { e.preventDefault(); this.bufferDirection(1, 0); }
            }

            bufferDirection(x, y) {
                // Add to input buffer (max 2 moves queued)
                if (this.inputBuffer.length < 2) {
                    const lastDir = this.inputBuffer.length > 0
                        ? this.inputBuffer[this.inputBuffer.length - 1]
                        : this.direction;
                    // Prevent 180 degree turns
                    if (!(lastDir.x === -x && x !== 0) && !(lastDir.y === -y && y !== 0)) {
                        this.inputBuffer.push({ x, y });
                    }
                }
            }

            setDirection(x, y) {
                if (this.direction.x === -x && x !== 0) return;
                if (this.direction.y === -y && y !== 0) return;
                this.nextDirection = { x, y };
            }

            // ==================== OVERLAYS ====================
            hideAllOverlays() {
                document.querySelectorAll('.game-overlay').forEach(o => o.classList.add('hidden'));
            }

            showMenu() {
                this.state = 'menu';
                this.stopGame();
                this.hideAllOverlays();
                document.getElementById('menuOverlay').classList.remove('hidden');
                this.renderMenu();
            }

            showSettings() {
                this.hideAllOverlays();
                document.getElementById('settingsOverlay').classList.remove('hidden');
            }

            showTutorial() {
                this.tutorialStep = 0;
                this.hideAllOverlays();
                document.getElementById('tutorialOverlay').classList.remove('hidden');
                this.renderTutorialStep();
            }

            renderTutorialStep() {
                const step = TUTORIAL_STEPS[this.tutorialStep];
                const container = document.getElementById('tutorialStep');

                let keysHtml = '';
                if (step.showKeys) {
                    keysHtml = `
                        <div class="tutorial-keys">
                            <div class="tutorial-key">W</div>
                        </div>
                        <div class="tutorial-keys">
                            <div class="tutorial-key">A</div>
                            <div class="tutorial-key">S</div>
                            <div class="tutorial-key">D</div>
                        </div>
                    `;
                }

                container.innerHTML = `
                    <div class="tutorial-icon">${step.icon}</div>
                    <div class="overlay-subtitle">${step.title}</div>
                    ${keysHtml}
                    <div class="tutorial-text">${step.text}</div>
                `;

                // Update dots
                const dotsContainer = document.getElementById('tutorialDots');
                dotsContainer.innerHTML = TUTORIAL_STEPS.map((_, i) =>
                    `<div class="tutorial-dot ${i === this.tutorialStep ? 'active' : ''}"></div>`
                ).join('');

                // Update buttons
                document.getElementById('tutorialPrev').style.visibility = this.tutorialStep === 0 ? 'hidden' : 'visible';
                document.getElementById('tutorialNext').textContent = this.tutorialStep === TUTORIAL_STEPS.length - 1 ? 'START' : 'NEXT';
            }

            tutorialPrevStep() {
                if (this.tutorialStep > 0) {
                    this.tutorialStep--;
                    this.renderTutorialStep();
                }
            }

            tutorialNextStep() {
                if (this.tutorialStep < TUTORIAL_STEPS.length - 1) {
                    this.tutorialStep++;
                    this.renderTutorialStep();
                } else {
                    this.showMenu();
                }
            }

            // ==================== MODALS ====================
            closeModal(id) {
                document.getElementById(id).classList.remove('active');
            }

            showStatsModal() {
                const grid = document.getElementById('statsGrid');
                const s = this.stats;
                grid.innerHTML = [
                    { label: 'Games Played', value: s.gamesPlayed },
                    { label: 'High Score', value: s.highScore },
                    { label: 'Total Score', value: s.totalScore },
                    { label: 'Max Length', value: s.maxLength },
                    { label: 'Max Combo', value: s.maxCombo },
                    { label: 'Power-ups', value: s.powerupsCollected },
                    { label: 'Bosses Defeated', value: s.bossesDefeated },
                    { label: 'Food Eaten', value: s.foodEaten },
                    { label: 'Play Time', value: Math.floor(s.totalPlayTime / 60) + 'm' },
                    { label: 'Achievements', value: this.unlockedAchievements.length + '/' + ACHIEVEMENTS.length }
                ].map(item => '<div class="stat-card"><div class="stat-card-value">' + item.value + '</div><div class="stat-card-label">' + item.label + '</div></div>').join('');
                document.getElementById('statsModal').classList.add('active');
            }

            showAchievementsModal() {
                const list = document.getElementById('achievementsList');
                list.innerHTML = ACHIEVEMENTS.map(a => {
                    const unlocked = this.unlockedAchievements.includes(a.id);
                    return '<div class="achievement-item ' + (unlocked ? 'unlocked' : '') + '">' +
                        '<div class="achievement-icon">' + (unlocked ? a.icon : '') + '</div>' +
                        '<div class="achievement-info"><div class="achievement-name">' + a.name + '</div>' +
                        '<div class="achievement-desc">' + a.desc + '</div></div></div>';
                }).join('');
                document.getElementById('achievementsModal').classList.add('active');
            }

            showKeybindsModal() {
                this.renderKeybinds();
                document.getElementById('keybindsModal').classList.add('active');
            }

            renderKeybinds() {
                const list = document.getElementById('keybindsList');
                const actions = { up: 'Move Up', down: 'Move Down', left: 'Move Left', right: 'Move Right',
                    pause: 'Pause', restart: 'Quick Restart', fullscreen: 'Fullscreen', menu: 'Menu', music: 'Toggle Music' };
                list.innerHTML = Object.entries(actions).map(([action, label]) => {
                    const keys = this.keybinds[action] || [];
                    const keyDisplay = keys.map(k => k === ' ' ? 'SPACE' : k.toUpperCase()).join(', ');
                    const isListening = this.listeningForKey === action;
                    return '<div class="keybind-row"><span class="keybind-action">' + label + '</span>' +
                        '<button type="button" class="keybind-key ' + (isListening ? 'listening' : '') + '" data-action="' + action + '">' +
                        (isListening ? 'Press key...' : keyDisplay) + '</button></div>';
                }).join('');

                list.querySelectorAll('.keybind-key').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.listeningForKey = btn.dataset.action;
                        this.renderKeybinds();
                    });
                });
            }

            resetKeybinds() {
                this.keybinds = JSON.parse(JSON.stringify(DEFAULT_KEYBINDS));
                this.saveData();
                this.renderKeybinds();
                this.showToast('Key bindings reset!');
            }

            showConfirmExit() {
                document.getElementById('confirmExitDialog').classList.add('active');
            }

            confirmExit(yes) {
                document.getElementById('confirmExitDialog').classList.remove('active');
                if (yes) {
                    this.showMenu();
                }
            }

            shareScore() {
                const text = 'I scored ' + this.score + ' points in Snakey Snacks! Can you beat my score?';
                if (navigator.share) {
                    navigator.share({ title: 'Snakey Snacks', text: text }).catch(() => {});
                } else if (navigator.clipboard) {
                    navigator.clipboard.writeText(text).then(() => {
                        this.showToast('Score copied to clipboard!');
                    });
                }
            }

            checkAchievements() {
                ACHIEVEMENTS.forEach(a => {
                    if (!this.unlockedAchievements.includes(a.id) && a.check(this.stats)) {
                        this.unlockedAchievements.push(a.id);
                        this.audio.achievement();
                        this.showToast('Achievement: ' + a.name + '!', 'achievement');
                    }
                });
                this.saveData();
            }

            checkDailyChallenge() {
                if (!this.dailyChallenge || this.dailyChallengeCompleted) return;

                const c = this.dailyChallenge;
                if (c.mode !== 'any' && c.mode !== this.gameMode) return;

                let completed = false;
                if (c.type === 'score' && this.score >= c.target) completed = true;
                if (c.type === 'length' && this.snake.length >= c.target) completed = true;
                if (c.type === 'gold' && this.goldCollected >= c.target) completed = true;
                if (c.type === 'combo' && this.combo >= c.target) completed = true;
                if (c.type === 'time') {
                    const survivalTime = (Date.now() - this.gameStartTime) / 1000;
                    if (survivalTime >= c.target) completed = true;
                }
                if (c.type === 'boss' && this.stats.bossesDefeated > 0) completed = true;

                if (completed) {
                    this.dailyChallengeCompleted = true;
                    this.stats.dailiesCompleted++;
                    this.showToast('Daily Challenge Complete!', 'achievement');
                    this.checkAchievements();
                }
            }

            // ==================== GAME CONTROL ====================
            startGame() {
                this.audio.init();

                // Apply difficulty settings
                const diffConfig = CONFIG.DIFFICULTIES[this.difficulty];
                this.speed = diffConfig.speed;
                this.baseSpeed = diffConfig.speed;
                this.gridSize = diffConfig.gridSize;
                this.cellSize = CONFIG.CANVAS_SIZE / this.gridSize;

                // Reset state
                const startX = Math.floor(this.gridSize / 2);
                const startY = Math.floor(this.gridSize / 2);
                this.snake = [
                    { x: startX, y: startY },
                    { x: startX - 1, y: startY },
                    { x: startX - 2, y: startY }
                ];
                this.visualSnake = this.snake.map(s => ({ ...s }));
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.inputBuffer = [];
                this.score = 0;
                this.level = 1;
                this.scoreMultiplier = 1;
                this.isInvincible = false;
                this.powerUp = null;
                this.powerUpActive = null;
                this.isBossLevel = false;
                this.obstacles = [];
                this.combo = 0;
                this.goldCollected = 0;
                this.currentRunData = [];

                if (this.powerUpTimer) clearTimeout(this.powerUpTimer);
                if (this.timerInterval) clearInterval(this.timerInterval);
                if (this.comboTimer) clearTimeout(this.comboTimer);

                // Mode specific setup
                if (this.gameMode === 'maze') {
                    this.generateObstacles();
                }

                if (this.gameMode === 'timed') {
                    this.timeLeft = CONFIG.TIMED_MODE_DURATION;
                    document.getElementById('timerRow').style.display = 'flex';
                    document.getElementById('timerBarContainer').style.display = 'block';
                } else {
                    document.getElementById('timerRow').style.display = 'none';
                    document.getElementById('timerBarContainer').style.display = 'none';
                }

                this.spawnFood();
                this.hideAllOverlays();
                document.getElementById('confirmExitDialog').classList.remove('active');
                this.updateUI();
                this.updateSpeedIndicator();

                // Show countdown
                this.showCountdown();
            }

            showCountdown() {
                const overlay = document.getElementById('countdownOverlay');
                const numberEl = document.getElementById('countdownNumber');
                overlay.style.display = 'flex';

                let count = 3;
                const tick = () => {
                    if (count > 0) {
                        numberEl.textContent = count;
                        numberEl.style.animation = 'none';
                        void numberEl.offsetWidth; // Trigger reflow
                        numberEl.style.animation = 'countdownPulse 1s ease-out';
                        this.audio.countdown(count);
                        count--;
                        setTimeout(tick, 1000);
                    } else {
                        numberEl.textContent = 'GO!';
                        numberEl.style.animation = 'none';
                        void numberEl.offsetWidth;
                        numberEl.style.animation = 'countdownPulse 1s ease-out';
                        this.audio.countdown(0);
                        setTimeout(() => {
                            overlay.style.display = 'none';
                            this.beginGameplay();
                        }, 500);
                    }
                };
                tick();
            }

            beginGameplay() {
                this.state = 'playing';
                this.gameStartTime = Date.now();

                if (this.gameMode === 'timed') {
                    this.startTimer();
                }

                if (this.gameLoop) cancelAnimationFrame(this.gameLoop);
                this.lastUpdate = performance.now();
                this.gameLoop = requestAnimationFrame((t) => this.loop(t));
            }

            updateSpeedIndicator() {
                const speedPercent = Math.round((this.baseSpeed / this.speed) * 100);
                document.getElementById('speedIndicator').textContent = 'SPEED: ' + speedPercent + '%';
            }

            updateComboDisplay() {
                const el = document.getElementById('comboDisplay');
                if (this.combo > 1) {
                    el.textContent = 'COMBO x' + this.combo;
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            }

            updatePowerupBar() {
                const container = document.getElementById('powerupBarContainer');
                const bar = document.getElementById('powerupBar');

                if (this.powerUpActive && this.powerUpStartTime > 0) {
                    const elapsed = Date.now() - this.powerUpStartTime;
                    const remaining = Math.max(0, CONFIG.POWERUP_DURATION - elapsed);
                    const percent = (remaining / CONFIG.POWERUP_DURATION) * 100;

                    container.classList.add('active');
                    bar.className = 'powerup-bar ' + this.powerUpActive;
                    bar.style.width = percent + '%';
                } else {
                    container.classList.remove('active');
                }
            }

            stopGame() {
                if (this.gameLoop) cancelAnimationFrame(this.gameLoop);
                if (this.timerInterval) clearInterval(this.timerInterval);
                if (this.powerUpTimer) clearTimeout(this.powerUpTimer);
                this.gameLoop = null;
            }

            pause() {
                if (this.state !== 'playing') return;
                this.state = 'paused';
                if (this.timerInterval) clearInterval(this.timerInterval);

                // Pause power-up timer
                if (this.powerUpActive && this.powerUpStartTime > 0) {
                    this.powerUpPausedTime = Date.now() - this.powerUpStartTime;
                    if (this.powerUpTimer) clearTimeout(this.powerUpTimer);
                }

                document.getElementById('pauseOverlay').classList.remove('hidden');
            }

            resume() {
                if (this.state !== 'paused') return;
                this.state = 'playing';
                document.getElementById('pauseOverlay').classList.add('hidden');

                if (this.gameMode === 'timed') {
                    this.startTimer();
                }

                // Resume power-up timer
                if (this.powerUpActive && this.powerUpPausedTime > 0) {
                    const remainingTime = CONFIG.POWERUP_DURATION - this.powerUpPausedTime;
                    this.powerUpStartTime = Date.now() - this.powerUpPausedTime;
                    if (remainingTime > 0) {
                        this.powerUpTimer = setTimeout(() => this.endPowerUp(), remainingTime);
                    } else {
                        this.endPowerUp();
                    }
                    this.powerUpPausedTime = 0;
                }

                this.lastUpdate = performance.now();
                this.gameLoop = requestAnimationFrame((t) => this.loop(t));
            }

            togglePause() {
                if (this.state === 'playing') this.pause();
                else if (this.state === 'paused') this.resume();
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    this.container.requestFullscreen().catch(err => {});
                } else {
                    document.exitFullscreen();
                }
            }

            // ==================== TIMER ====================
            startTimer() {
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if (this.state !== 'playing') return;
                    this.timeLeft--;
                    document.getElementById('timeLeft').textContent = this.timeLeft;
                    document.getElementById('timerBar').style.width = (this.timeLeft / CONFIG.TIMED_MODE_DURATION * 100) + '%';

                    if (this.timeLeft <= 0) {
                        clearInterval(this.timerInterval);
                        this.gameOver();
                    }
                }, 1000);
            }

            // ==================== OBSTACLES ====================
            generateObstacles() {
                this.obstacles = [];
                const count = 5 + this.level * 2;

                for (let i = 0; i < count; i++) {
                    let pos;
                    let attempts = 0;
                    do {
                        pos = {
                            x: Math.floor(Math.random() * this.gridSize),
                            y: Math.floor(Math.random() * this.gridSize)
                        };
                        attempts++;
                    } while (attempts < 100 && (
                        this.snake.some(s => Math.abs(s.x - pos.x) < 3 && Math.abs(s.y - pos.y) < 3) ||
                        this.obstacles.some(o => o.x === pos.x && o.y === pos.y)
                    ));

                    if (attempts < 100) {
                        this.obstacles.push(pos);
                    }
                }
            }

            // ==================== BOSS LEVEL ====================
            checkBossLevel() {
                if (this.level > 0 && this.level % CONFIG.BOSS_LEVEL_INTERVAL === 0 && !this.isBossLevel) {
                    this.triggerBossLevel();
                }
            }

            triggerBossLevel() {
                this.state = 'boss';
                this.audio.bossAlert();
                this.bossObjective = 5 + Math.floor(this.level / 5);
                this.bossProgress = 0;

                document.getElementById('bossObjective').textContent = `Collect ${this.bossObjective} golden fruits!`;
                document.getElementById('bossOverlay').classList.remove('hidden');
            }

            startBossLevel() {
                this.isBossLevel = true;
                this.hideAllOverlays();
                this.state = 'playing';

                // Spawn only gold food during boss
                this.food = null;
                this.spawnFood(true);

                this.lastUpdate = performance.now();
                this.gameLoop = requestAnimationFrame((t) => this.loop(t));
            }

            completeBossLevel() {
                this.isBossLevel = false;
                this.bossProgress = 0;
                this.score += 100 * this.level;
                this.stats.bossesDefeated++;
                this.audio.levelUp();
                this.showToast('Boss defeated! +' + (100 * this.level) + ' bonus!');
                this.checkAchievements();
                this.checkDailyChallenge();
                this.updateUI();
            }

            renderMinimap() {
                const ctx = this.minimapCtx;
                const scale = 80 / this.gridSize;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, 80, 80);

                // Draw obstacles
                ctx.fillStyle = '#ff0044';
                this.obstacles.forEach(o => {
                    ctx.fillRect(o.x * scale, o.y * scale, scale, scale);
                });

                // Draw food
                if (this.food) {
                    ctx.fillStyle = CONFIG.FOOD_TYPES[this.food.type].color;
                    ctx.fillRect(this.food.x * scale, this.food.y * scale, scale, scale);
                }

                // Draw power-up
                if (this.powerUp) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(this.powerUp.x * scale, this.powerUp.y * scale, scale, scale);
                }

                // Draw snake
                this.snake.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#ff00ff' : '#cc00cc';
                    ctx.fillRect(s.x * scale, s.y * scale, scale, scale);
                });
            }

            // ==================== GAME LOOP ====================
            loop(timestamp) {
                if (this.state !== 'playing') return;

                const elapsed = timestamp - this.lastUpdate;

                if (elapsed >= this.speed) {
                    this.update();
                    this.lastUpdate = timestamp;
                    this.interpolation = 0;
                } else if (this.settings.smooth) {
                    this.interpolation = elapsed / this.speed;
                }

                this.render();
                this.updatePowerupBar();
                if (this.settings.minimap) this.renderMinimap();
                this.gameLoop = requestAnimationFrame((t) => this.loop(t));
            }

            update() {
                // Process input buffer
                if (this.inputBuffer.length > 0) {
                    this.nextDirection = this.inputBuffer.shift();
                }
                this.direction = { ...this.nextDirection };

                const head = this.snake[0];
                const newHead = {
                    x: head.x + this.direction.x,
                    y: head.y + this.direction.y
                };

                // Wall collision
                if (this.gameMode === 'endless') {
                    newHead.x = (newHead.x + this.gridSize) % this.gridSize;
                    newHead.y = (newHead.y + this.gridSize) % this.gridSize;
                } else if (newHead.x < 0 || newHead.x >= this.gridSize || newHead.y < 0 || newHead.y >= this.gridSize) {
                    if (!this.isInvincible) {
                        this.gameOver();
                        return;
                    }
                    newHead.x = (newHead.x + this.gridSize) % this.gridSize;
                    newHead.y = (newHead.y + this.gridSize) % this.gridSize;
                }

                // Self collision
                if (this.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
                    if (!this.isInvincible) {
                        this.gameOver();
                        return;
                    }
                }

                // Obstacle collision
                if (this.obstacles.some(o => o.x === newHead.x && o.y === newHead.y)) {
                    if (!this.isInvincible) {
                        this.gameOver();
                        return;
                    }
                }

                // Trail effect
                if (this.settings.trail) {
                    const trailX = head.x * this.cellSize + this.cellSize / 2;
                    const trailY = head.y * this.cellSize + this.cellSize / 2;
                    this.particles.trail(trailX, trailY, this.getSnakeColor(0));
                }

                this.snake.unshift(newHead);
                this.visualSnake.unshift({ ...newHead });

                // Food collision
                if (newHead.x === this.food.x && newHead.y === this.food.y) {
                    this.eatFood();
                } else {
                    this.snake.pop();
                    this.visualSnake.pop();
                }

                // Power-up collision
                if (this.powerUp && newHead.x === this.powerUp.x && newHead.y === this.powerUp.y) {
                    this.collectPowerUp();
                }
            }

            eatFood() {
                const foodType = this.food.type;

                // Combo system
                const now = Date.now();
                if (now - this.lastEatTime < CONFIG.COMBO_TIMEOUT) {
                    this.combo++;
                    this.audio.combo(this.combo);
                } else {
                    this.combo = 1;
                }
                this.lastEatTime = now;

                // Reset combo timer
                if (this.comboTimer) clearTimeout(this.comboTimer);
                this.comboTimer = setTimeout(() => {
                    this.combo = 0;
                    this.updateComboDisplay();
                }, CONFIG.COMBO_TIMEOUT);

                // Calculate points with combo bonus
                const comboBonus = 1 + (this.combo - 1) * 0.1;
                const points = Math.floor(CONFIG.FOOD_TYPES[foodType].points * this.scoreMultiplier * comboBonus);
                this.score += points;
                this.audio.eat(foodType);

                // Track gold for daily challenge
                if (foodType === 'gold') this.goldCollected++;

                // Stats
                this.stats.foodEaten++;
                if (this.combo > this.stats.maxCombo) this.stats.maxCombo = this.combo;
                if (this.snake.length > this.stats.maxLength) this.stats.maxLength = this.snake.length;

                const cellX = this.food.x * this.cellSize + this.cellSize / 2;
                const cellY = this.food.y * this.cellSize + this.cellSize / 2;
                this.particles.emit(cellX, cellY, CONFIG.FOOD_TYPES[foodType].color);

                // Boss progress
                if (this.isBossLevel && foodType === 'gold') {
                    this.bossProgress++;
                    if (this.bossProgress >= this.bossObjective) {
                        this.completeBossLevel();
                    }
                }

                // Level up
                const newLevel = Math.floor(this.score / 100) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.speed = Math.max(80, this.speed - 3);
                    this.audio.levelUp();
                    this.updateSpeedIndicator();

                    if (this.gameMode === 'maze') {
                        this.generateObstacles();
                    }

                    this.checkBossLevel();
                }

                // Time bonus in timed mode
                if (this.gameMode === 'timed') {
                    this.timeLeft = Math.min(CONFIG.TIMED_MODE_DURATION, this.timeLeft + 2);
                }

                this.spawnFood(this.isBossLevel);

                if (!this.powerUp && !this.isBossLevel && Math.random() < CONFIG.POWERUP_SPAWN_CHANCE) {
                    this.spawnPowerUp();
                }

                this.updateUI();
                this.updateComboDisplay();
                this.checkDailyChallenge();
            }

            spawnFood(goldOnly = false) {
                let position, type;
                let attempts = 0;

                do {
                    position = {
                        x: Math.floor(Math.random() * this.gridSize),
                        y: Math.floor(Math.random() * this.gridSize)
                    };
                    attempts++;
                } while (
                    attempts < CONFIG.MAX_SPAWN_ATTEMPTS &&
                    (this.snake.some(s => s.x === position.x && s.y === position.y) ||
                    this.obstacles.some(o => o.x === position.x && o.y === position.y) ||
                    (this.powerUp && this.powerUp.x === position.x && this.powerUp.y === position.y))
                );

                // If grid is full, find any empty spot
                if (attempts >= CONFIG.MAX_SPAWN_ATTEMPTS) {
                    for (let x = 0; x < this.gridSize; x++) {
                        for (let y = 0; y < this.gridSize; y++) {
                            const occupied = this.snake.some(s => s.x === x && s.y === y) ||
                                this.obstacles.some(o => o.x === x && o.y === y) ||
                                (this.powerUp && this.powerUp.x === x && this.powerUp.y === y);
                            if (!occupied) {
                                position = { x, y };
                                break;
                            }
                        }
                    }
                }

                if (goldOnly) {
                    type = 'gold';
                } else {
                    const rand = Math.random();
                    if (rand < CONFIG.FOOD_TYPES.apple.chance) type = 'apple';
                    else if (rand < CONFIG.FOOD_TYPES.apple.chance + CONFIG.FOOD_TYPES.cherry.chance) type = 'cherry';
                    else type = 'gold';
                }

                this.food = { ...position, type };
            }

            spawnPowerUp() {
                const types = ['speed', 'shield', 'multiplier'];
                let position;
                let attempts = 0;

                do {
                    position = {
                        x: Math.floor(Math.random() * this.gridSize),
                        y: Math.floor(Math.random() * this.gridSize)
                    };
                    attempts++;
                } while (
                    attempts < CONFIG.MAX_SPAWN_ATTEMPTS &&
                    (this.snake.some(s => s.x === position.x && s.y === position.y) ||
                    this.obstacles.some(o => o.x === position.x && o.y === position.y) ||
                    (this.food && this.food.x === position.x && this.food.y === position.y))
                );

                if (attempts >= CONFIG.MAX_SPAWN_ATTEMPTS) return; // Don't spawn if no space

                this.powerUp = { ...position, type: types[Math.floor(Math.random() * types.length)] };
            }

            collectPowerUp() {
                this.audio.powerUp();

                const cellX = this.powerUp.x * this.cellSize + this.cellSize / 2;
                const cellY = this.powerUp.y * this.cellSize + this.cellSize / 2;
                const colors = { speed: '#ffff00', shield: '#00ffff', multiplier: '#ff00ff' };
                this.particles.emit(cellX, cellY, colors[this.powerUp.type], 12);

                this.powerUpActive = this.powerUp.type;
                this.powerUpStartTime = Date.now();
                this.stats.powerupsCollected++;

                switch (this.powerUp.type) {
                    case 'speed':
                        this.speed = Math.max(60, this.speed - 25);
                        this.updateSpeedIndicator();
                        break;
                    case 'shield': this.isInvincible = true; break;
                    case 'multiplier': this.scoreMultiplier = 2; break;
                }

                this.powerUp = null;

                if (this.powerUpTimer) clearTimeout(this.powerUpTimer);
                this.powerUpTimer = setTimeout(() => this.endPowerUp(), CONFIG.POWERUP_DURATION);

                this.updateUI();
            }

            endPowerUp() {
                if (this.powerUpActive === 'speed') {
                    const diffConfig = CONFIG.DIFFICULTIES[this.difficulty];
                    this.speed = Math.max(80, diffConfig.speed - (this.level - 1) * 3);
                    this.updateSpeedIndicator();
                } else if (this.powerUpActive === 'shield') {
                    this.isInvincible = false;
                } else if (this.powerUpActive === 'multiplier') {
                    this.scoreMultiplier = 1;
                }
                this.powerUpActive = null;
                this.powerUpStartTime = 0;
            }

            gameOver() {
                this.state = 'gameover';
                this.stopGame();
                this.audio.gameOver();

                // Death animation - flash effect
                this.canvas.classList.add('death-flash');
                setTimeout(() => this.canvas.classList.remove('death-flash'), 500);

                // Screen shake
                this.container.classList.add('shake');
                setTimeout(() => this.container.classList.remove('shake'), 500);

                // Update stats
                const survivalTime = (Date.now() - this.gameStartTime) / 1000;
                this.stats.gamesPlayed++;
                this.stats.totalScore += this.score;
                this.stats.totalPlayTime += survivalTime;
                if (this.score > this.stats.highScore) this.stats.highScore = this.score;
                if (survivalTime > this.stats.longestSurvival) this.stats.longestSurvival = survivalTime;
                if (this.difficulty === 'hard' && this.score >= 500) this.stats.hardWins++;

                let isNewHighScore = false;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    isNewHighScore = true;
                    // Save ghost data for best run
                    this.ghostData = [...this.currentRunData];
                }

                this.addToLeaderboard(this.playerName, this.score);
                this.checkAchievements();
                this.saveData();

                document.getElementById('finalScore').textContent = 'Score: ' + this.score;
                document.getElementById('gameOverStats').textContent = 'Level: ' + this.level + ' | Length: ' + this.snake.length;
                document.getElementById('newHighScore').style.display = isNewHighScore ? 'block' : 'none';
                document.getElementById('gameOverOverlay').classList.remove('hidden');

                this.updateUI();
            }

            addToLeaderboard(name, score) {
                this.leaderboard.push({ name, score, mode: this.gameMode, date: new Date().toISOString() });
                this.leaderboard.sort((a, b) => b.score - a.score);
                this.leaderboard = this.leaderboard.slice(0, 10);
                this.updateLeaderboard();
            }

            updateLeaderboard() {
                const list = document.getElementById('leaderboardList');

                if (this.leaderboard.length === 0) {
                    list.innerHTML = '<div style="text-align: center; color: #666; font-size: 7px;">No scores yet</div>';
                    return;
                }

                // Build leaderboard safely to prevent XSS
                list.innerHTML = '';
                this.leaderboard.forEach((entry, i) => {
                    const div = document.createElement('div');
                    div.className = 'leaderboard-entry' + (i === 0 ? ' gold' : i === 1 ? ' silver' : i === 2 ? ' bronze' : '');

                    const rank = document.createElement('span');
                    rank.className = 'rank ' + (i < 3 ? 'rank-' + (i + 1) : 'rank-default');
                    rank.textContent = i + 1;

                    const name = document.createElement('span');
                    name.className = 'entry-name';
                    name.textContent = entry.name; // Safe - using textContent

                    const score = document.createElement('span');
                    score.className = 'entry-score';
                    score.textContent = entry.score;

                    div.appendChild(rank);
                    div.appendChild(name);
                    div.appendChild(score);
                    list.appendChild(div);
                });
            }

            updateUI() {
                document.getElementById('currentScore').textContent = this.score;
                document.getElementById('highScore').textContent = this.highScore;
                document.getElementById('currentLevel').textContent = this.level;
                document.getElementById('snakeLength').textContent = this.snake.length;
            }

            // ==================== RENDERING ====================
            getSnakeColor(index) {
                const skin = this.settings.skin;
                const time = Date.now() / 100;

                if (this.isInvincible) {
                    return `hsl(${(index * 20 + time * 10) % 360}, 100%, 50%)`;
                }

                switch (skin) {
                    case 'rainbow':
                        return `hsl(${(index * 15 + time * 2) % 360}, 100%, 50%)`;
                    case 'fire':
                        const fireHue = 0 + index * 3;
                        return `hsl(${fireHue}, 100%, ${60 - index * 0.5}%)`;
                    case 'ice':
                        const iceHue = 180 + index * 2;
                        return `hsl(${iceHue}, 100%, ${70 - index * 0.5}%)`;
                    case 'pixel':
                        return index === 0 ? '#00ff00' : '#00cc00';
                    default: // classic
                        return index === 0 ? '#ff00ff' : `hsl(${280 + index * 2}, 100%, ${60 - index * 0.5}%)`;
                }
            }

            renderMenu() {
                const ctx = this.ctx;
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, CONFIG.CANVAS_SIZE, CONFIG.CANVAS_SIZE);

                // Animated background for menu
                const time = Date.now() / 1000;
                for (let i = 0; i < 5; i++) {
                    const x = Math.sin(time + i) * 100 + 250;
                    const y = Math.cos(time * 0.7 + i) * 100 + 250;
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 100);
                    gradient.addColorStop(0, `hsla(${(time * 50 + i * 60) % 360}, 100%, 50%, 0.1)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, CONFIG.CANVAS_SIZE, CONFIG.CANVAS_SIZE);
                }

                if (this.state === 'menu') {
                    requestAnimationFrame(() => this.renderMenu());
                }
            }

            render() {
                const ctx = this.ctx;
                const cellSize = this.cellSize;

                // Clear
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, CONFIG.CANVAS_SIZE, CONFIG.CANVAS_SIZE);

                // Theme background effects
                this.renderThemeBackground(ctx);

                // Grid
                if (this.settings.showGrid) {
                    ctx.strokeStyle = '#1a1a2e';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= this.gridSize; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * cellSize, 0);
                        ctx.lineTo(i * cellSize, CONFIG.CANVAS_SIZE);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, i * cellSize);
                        ctx.lineTo(CONFIG.CANVAS_SIZE, i * cellSize);
                        ctx.stroke();
                    }
                }

                // Obstacles
                this.obstacles.forEach(obs => {
                    ctx.fillStyle = '#ff0044';
                    ctx.shadowColor = '#ff0044';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(obs.x * cellSize + 2, obs.y * cellSize + 2, cellSize - 4, cellSize - 4);
                    ctx.shadowBlur = 0;
                });

                // Food
                if (this.food) {
                    const foodConfig = CONFIG.FOOD_TYPES[this.food.type];
                    const foodX = this.food.x * cellSize + cellSize / 2;
                    const foodY = this.food.y * cellSize + cellSize / 2;
                    const pulse = Math.sin(Date.now() / 200) * 2 + cellSize / 3;

                    ctx.fillStyle = foodConfig.color;
                    ctx.shadowColor = foodConfig.color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(foodX, foodY, pulse, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.shadowBlur = 0;
                    ctx.font = `${cellSize / 3}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(foodConfig.char, foodX, foodY);
                }

                // Power-up
                if (this.powerUp) {
                    const puX = this.powerUp.x * cellSize + cellSize / 2;
                    const puY = this.powerUp.y * cellSize + cellSize / 2;
                    const pulse = Math.sin(Date.now() / 150) * 3 + cellSize / 3;
                    const colors = { speed: '#ffff00', shield: '#00ffff', multiplier: '#ff00ff' };
                    const icons = { speed: 'S', shield: 'I', multiplier: 'x2' };

                    ctx.fillStyle = colors[this.powerUp.type];
                    ctx.shadowColor = colors[this.powerUp.type];
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(puX, puY, pulse, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.shadowBlur = 0;
                    ctx.font = `${cellSize / 4}px "Press Start 2P"`;
                    ctx.fillText(icons[this.powerUp.type], puX, puY);
                }

                // Snake
                this.snake.forEach((segment, index) => {
                    let x = segment.x * cellSize;
                    let y = segment.y * cellSize;

                    // Smooth interpolation
                    if (this.settings.smooth && index === 0 && this.interpolation > 0) {
                        x += this.direction.x * cellSize * this.interpolation;
                        y += this.direction.y * cellSize * this.interpolation;
                    }

                    const color = this.getSnakeColor(index);
                    const isHead = index === 0;

                    ctx.shadowColor = color;
                    ctx.shadowBlur = isHead ? 20 : 10;
                    ctx.fillStyle = color;

                    const padding = 2;
                    const radius = isHead ? cellSize / 4 : cellSize / 5;

                    ctx.beginPath();
                    ctx.roundRect(x + padding, y + padding, cellSize - padding * 2, cellSize - padding * 2, radius);
                    ctx.fill();

                    // Eyes
                    if (isHead) {
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#fff';

                        const eyeSize = cellSize / 8;
                        const eyeOffset = cellSize / 4;
                        let e1x, e1y, e2x, e2y;

                        if (this.direction.x === 1) {
                            e1x = x + cellSize - eyeOffset; e1y = y + eyeOffset;
                            e2x = x + cellSize - eyeOffset; e2y = y + cellSize - eyeOffset;
                        } else if (this.direction.x === -1) {
                            e1x = x + eyeOffset; e1y = y + eyeOffset;
                            e2x = x + eyeOffset; e2y = y + cellSize - eyeOffset;
                        } else if (this.direction.y === -1) {
                            e1x = x + eyeOffset; e1y = y + eyeOffset;
                            e2x = x + cellSize - eyeOffset; e2y = y + eyeOffset;
                        } else {
                            e1x = x + eyeOffset; e1y = y + cellSize - eyeOffset;
                            e2x = x + cellSize - eyeOffset; e2y = y + cellSize - eyeOffset;
                        }

                        ctx.beginPath();
                        ctx.arc(e1x, e1y, eyeSize, 0, Math.PI * 2);
                        ctx.arc(e2x, e2y, eyeSize, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(e1x, e1y, eyeSize / 2, 0, Math.PI * 2);
                        ctx.arc(e2x, e2y, eyeSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.shadowBlur = 0;
                });

                // Power-up indicator
                if (this.powerUpActive) {
                    const colors = { speed: '#ffff00', shield: '#00ffff', multiplier: '#ff00ff' };
                    const labels = { speed: 'SPEED!', shield: 'SHIELD!', multiplier: 'x2!' };

                    ctx.fillStyle = colors[this.powerUpActive];
                    ctx.shadowColor = colors[this.powerUpActive];
                    ctx.shadowBlur = 10;
                    ctx.font = '10px "Press Start 2P"';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(labels[this.powerUpActive], 10, 10);
                    ctx.shadowBlur = 0;
                }

                // Boss indicator
                if (this.isBossLevel) {
                    ctx.fillStyle = '#ff0044';
                    ctx.shadowColor = '#ff0044';
                    ctx.shadowBlur = 15;
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`BOSS: ${this.bossProgress}/${this.bossObjective}`, CONFIG.CANVAS_SIZE / 2, 10);
                    ctx.shadowBlur = 0;
                }
            }

            renderThemeBackground(ctx) {
                const theme = this.settings.theme;
                const time = Date.now() / 1000;

                if (theme === 'space') {
                    // Stars
                    for (let i = 0; i < 30; i++) {
                        const x = (Math.sin(i * 123.456) * 0.5 + 0.5) * CONFIG.CANVAS_SIZE;
                        const y = (Math.cos(i * 789.012) * 0.5 + 0.5) * CONFIG.CANVAS_SIZE;
                        const twinkle = Math.sin(time * 2 + i) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 1 + twinkle, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (theme === 'underwater') {
                    // Bubbles
                    for (let i = 0; i < 10; i++) {
                        const x = (Math.sin(i * 234.567) * 0.5 + 0.5) * CONFIG.CANVAS_SIZE;
                        const y = ((time * 20 + i * 50) % CONFIG.CANVAS_SIZE);
                        ctx.strokeStyle = 'rgba(0, 200, 255, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(x, CONFIG.CANVAS_SIZE - y, 3 + i % 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (theme === 'forest') {
                    // Leaves falling effect
                    ctx.fillStyle = 'rgba(0, 100, 0, 0.05)';
                    for (let i = 0; i < 5; i++) {
                        const x = (Math.sin(time + i * 2) * 100 + 100 * i) % CONFIG.CANVAS_SIZE;
                        const y = (time * 30 + i * 100) % CONFIG.CANVAS_SIZE;
                        ctx.beginPath();
                        ctx.ellipse(x, y, 5, 3, Math.sin(time + i), 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        // ==================== INITIALIZE ====================
        const game = new SnakeGame();
    </script>
</body>
</html>
